<!DOCTYPE html>
<html>
<head>
  <title>Dashboard</title>
  <link rel="manifest" href="{{ url_for('static', filename='manifest.json') }}">
  <meta name="theme-color" content="#1a73e8" />
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="apple-touch-icon" href="{{ url_for('static', filename='icons/icon-192.png') }}">
  
  <!-- Add app-style.css for PWA styling -->
  <link rel="stylesheet" href="{{ url_for('static', filename='css/app-style.css') }}">
</head>

<body>
  <div class="app-shell">
    <header class="app-header">
      <h1>Face Attendance</h1>
      <button id="installBtn" class="install-btn">Install App</button>
    </header>

    <main class="app-content">
      <h2>Welcome, {{ username }}</h2>
      <p>Status: <strong id="status">{{ status }}</strong></p>

      <div class="action-buttons">
        <button onclick="punchin()" class="btn punch-in">Punch In</button>
        <button onclick="punchout()" class="btn punch-out">Punch Out</button>
      </div>

      <nav class="app-nav">
        <a href="{{ url_for('summary') }}" class="nav-link">View Summary</a>
        <a href="/logout" class="nav-link">Logout</a>
      </nav>
    </main>

    <div class="offline-status" id="offlineStatus"></div>
  </div>

  <script>
    // Enhanced Service Worker Registration
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register("{{ url_for('static', filename='js/service-worker.js') }}")
          .then(reg => {
            console.log("Service Worker registered");
            reg.update(); // Force update check
          })
          .catch(err => console.log("Service Worker registration failed:", err));
      });
    }

    // Install Prompt Handling
    let deferredPrompt;
    window.addEventListener('beforeinstallprompt', (e) => {
      e.preventDefault();
      deferredPrompt = e;
      const installBtn = document.getElementById('installBtn');
      installBtn.style.display = 'block';
      
      installBtn.addEventListener('click', () => {
        installBtn.style.display = 'none';
        deferredPrompt.prompt();
        deferredPrompt.userChoice.then(choiceResult => {
          if (choiceResult.outcome === 'accepted') {
            console.log('User accepted install');
          }
          deferredPrompt = null;
        });
      });
    });

    // Offline Detection
    window.addEventListener('online', updateOnlineStatus);
    window.addEventListener('offline', updateOnlineStatus);

    function updateOnlineStatus() {
      const statusDisplay = document.getElementById('offlineStatus');
      if (navigator.onLine) {
        statusDisplay.textContent = '';
        statusDisplay.style.display = 'none';
      } else {
        statusDisplay.textContent = '⚠️ Offline - Working in offline mode';
        statusDisplay.style.display = 'block';
      }
    }
    updateOnlineStatus();

    // Punch In/Out functions with offline support
    async function punchin() {
      try {
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject);
        });
        
        const response = await fetch('/punchin', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            timestamp: new Date().toISOString()
          })
        });

        if (!response.ok) throw new Error(await response.text());
        
        alert('Punched In!');
        document.getElementById('status').textContent = 'IN';
        
        // Sync with server when back online
        if (!navigator.onLine) {
          // You could implement IndexedDB storage for offline punches
          console.log('Punch stored for sync when online');
        }
      } catch (err) {
        alert('Error: ' + err.message);
      }
    }

    // Similar implementation for punchout()
    async function punchout() {
      try {
    // Get current position
        const position = await new Promise((resolve, reject) => {
          navigator.geolocation.getCurrentPosition(resolve, reject, {
            enableHighAccuracy: true,
            timeout: 10000,
            maximumAge: 0
          });
        });

    // Send punch out request
        const response = await fetch('/punchout', {
          method: 'POST',
          headers: {'Content-Type': 'application/json'},
          body: JSON.stringify({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude
          })
        });

    // Handle response
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          throw new Error(errorData.message || 'Punch out failed');
        }

        const data = await response.json();
        alert(data.message || 'Punched Out Successfully!');
        document.getElementById('status').textContent = 'OUT';
    
      } catch (error) {
        console.error('Punch out error:', error);
        alert(`Error: ${error.message}`);
    
    // If offline, you could store the punch for later sync
        if (!navigator.onLine) {
          alert('You appear to be offline. This punch will be synced when you reconnect.');
      // Here you would add IndexedDB storage logic
        }
      }
    }
        
  </script>
</body>
</html>